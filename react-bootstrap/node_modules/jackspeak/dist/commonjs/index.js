"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.jack = exports.Jack = exports.isConfigOption = exports.isConfigType = void 0;
const node_util_1 = require("node:util");
const parse_args_js_1 = require("./parse-args.js");
// it's a tiny API, just cast it inline, it's fine
//@ts-ignore
const cliui_1 = __importDefault(require("@isaacs/cliui"));
const node_path_1 = require("node:path");
const width = Math.min((process && process.stdout && process.stdout.columns) || 80, 80);
// indentation spaces from heading level
const indent = (n) => (n - 1) * 2;
const toEnvKey = (pref, key) => {
    return [pref, key.replace(/[^a-zA-Z0-9]+/g, ' ')]
        .join(' ')
        .trim()
        .toUpperCase()
        .replace(/ /g, '_');
};
const toEnvVal = (value, delim = '\n') => {
    const str = typeof value === 'string' ? value
        : typeof value === 'boolean' ?
            value ? '1'
                : '0'
            : typeof value === 'number' ? String(value)
                : Array.isArray(value) ?
                    value.map((v) => toEnvVal(v)).join(delim)
                    : /* c8 ignore start */ undefined;
    if (typeof str !== 'string') {
        throw new Error(`could not serialize value to environment: ${JSON.stringify(value)}`);
    }
    /* c8 ignore stop */
    return str;
};
const fromEnvVal = (env, type, multiple, delim = '\n') => (multiple ?
    env ? env.split(delim).map(v => fromEnvVal(v, type, false))
        : []
    : type === 'string' ? env
        : type === 'boolean' ? env === '1'
            : +env.trim());
const isConfigType = (t) => typeof t === 'string' &&
    (t === 'string' || t === 'number' || t === 'boolean');
exports.isConfigType = isConfigType;
const undefOrType = (v, t) => v === undefined || typeof v === t;
const undefOrTypeArray = (v, t) => v === undefined || (Array.isArray(v) && v.every(x => typeof x === t));
const isValidOption = (v, vo) => Array.isArray(v) ? v.every(x => isValidOption(x, vo)) : vo.includes(v);
// print the value type, for error message reporting
const valueType = (v) => typeof v === 'string' ? 'string'
    : typeof v === 'boolean' ? 'boolean'
        : typeof v === 'number' ? 'number'
            : Array.isArray(v) ?
                joinTypes([...new Set(v.map(v => valueType(v)))]) + '[]'
                : `${v.type}${v.multiple ? '[]' : ''}`;
const joinTypes = (types) => types.length === 1 && typeof types[0] === 'string' ?
    types[0]
    : `(${types.join('|')})`;
const isValidValue = (v, type, multi) => {
    if (multi) {
        if (!Array.isArray(v))
            return false;
        return !v.some((v) => !isValidValue(v, type, false));
    }
    if (Array.isArray(v))
        return false;
    return typeof v === type;
};
const isConfigOption = (o, type, multi) => !!o &&
    typeof o === 'object' &&
    (0, exports.isConfigType)(o.type) &&
    o.type === type &&
    undefOrType(o.short, 'string') &&
    undefOrType(o.description, 'string') &&
    undefOrType(o.hint, 'string') &&
    undefOrType(o.validate, 'function') &&
    (o.type === 'boolean' ?
        o.validOptions === undefined
        : undefOrTypeArray(o.validOptions, o.type)) &&
    (o.default === undefined || isValidValue(o.default, type, multi)) &&
    !!o.multiple === multi;
exports.isConfigOption = isConfigOption;
function num(o = {}) {
    const { default: def, validate: val, validOptions, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'number', false)) {
        throw new TypeError('invalid default value', {
            cause: {
                found: def,
                wanted: 'number',
            },
        });
    }
    if (!undefOrTypeArray(validOptions, 'number')) {
        throw new TypeError('invalid validOptions', {
            cause: {
                found: validOptions,
                wanted: 'number[]',
            },
        });
    }
    const validate = val ?
        val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        validOptions,
        type: 'number',
        multiple: false,
    };
}
function numList(o = {}) {
    const { default: def, validate: val, validOptions, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'number', true)) {
        throw new TypeError('invalid default value', {
            cause: {
                found: def,
                wanted: 'number[]',
            },
        });
    }
    if (!undefOrTypeArray(validOptions, 'number')) {
        throw new TypeError('invalid validOptions', {
            cause: {
                found: validOptions,
                wanted: 'number[]',
            },
        });
    }
    const validate = val ?
        val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        validOptions,
        type: 'number',
        multiple: true,
    };
}
function opt(o = {}) {
    const { default: def, validate: val, validOptions, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'string', false)) {
        throw new TypeError('invalid default value', {
            cause: {
                found: def,
                wanted: 'string',
            },
        });
    }
    if (!undefOrTypeArray(validOptions, 'string')) {
        throw new TypeError('invalid validOptions', {
            cause: {
                found: validOptions,
                wanted: 'string[]',
            },
        });
    }
    const validate = val ?
        val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        validOptions,
        type: 'string',
        multiple: false,
    };
}
function optList(o = {}) {
    const { default: def, validate: val, validOptions, ...rest } = o;
    if (def !== undefined && !isValidValue(def, 'string', true)) {
        throw new TypeError('invalid default value', {
            cause: {
                found: def,
                wanted: 'string[]',
            },
        });
    }
    if (!undefOrTypeArray(validOptions, 'string')) {
        throw new TypeError('invalid validOptions', {
            cause: {
                found: validOptions,
                wanted: 'string[]',
            },
        });
    }
    const validate = val ?
        val
        : undefined;
    return {
        ...rest,
        default: def,
        validate,
        validOptions,
        type: 'string',
        multiple: true,
    };
}
function flag(o = {}) {
    const { hint, default: def, validate: val, ...rest } = o;
    delete rest.validOptions;
    if (def !== undefined && !isValidValue(def, 'boolean', false)) {
        throw new TypeError('invalid default value');
    }
    const validate = val ?
        val
        : undefined;
    if (hint !== undefined) {
        throw new TypeError('cannot provide hint for flag');
    }
    return {
        ...rest,
        default: def,
        validate,
        type: 'boolean',
        multiple: false,
    };
}
function flagList(o = {}) {
    const { hint, default: def, validate: val, ...rest } = o;
    delete rest.validOptions;
    if (def !== undefined && !isValidValue(def, 'boolean', true)) {
        throw new TypeError('invalid default value');
    }
    const validate = val ?
        val
        : undefined;
    if (hint !== undefined) {
        throw new TypeError('cannot provide hint for flag list');
    }
    return {
        ...rest,
        default: def,
        validate,
        type: 'boolean',
        multiple: true,
    };
}
const toParseArgsOptionsConfig = (options) => {
    const c = {};
    for (const longOption in options) {
        const config = options[longOption];
        /* c8 ignore start */
        if (!config) {
            throw new Error('config must be an object: ' + longOption);
        }
        /* c8 ignore start */
        if ((0, exports.isConfigOption)(config, 'number', true)) {
            c[longOption] = {
                type: 'string',
                multiple: true,
                default: config.default?.map(c => String(c)),
            };
        }
        else if ((0, exports.isConfigOption)(config, 'number', false)) {
            c[longOption] = {
                type: 'string',
                multiple: false,
                default: config.default === undefined ?
                    undefined
                    : String(config.default),
            };
        }
        else {
            const conf = config;
            c[longOption] = {
                type: conf.type,
                multiple: !!conf.multiple,
                default: conf.default,
            };
        }
        const clo = c[longOption];
        if (typeof config.short === 'string') {
            clo.short = config.short;
        }
        if (config.type === 'boolean' &&
            !longOption.startsWith('no-') &&
            !options[`no-${longOption}`]) {
            c[`no-${longOption}`] = {
                type: 'boolean',
                multiple: config.multiple,
            };
        }
    }
    return c;
};
const isHeading = (r) => r.type === 'heading';
const isDescription = (r) => r.type === 'description';
/**
 * Class returned by the {@link jack} function and all configuration
 * definition methods.  This is what gets chained together.
 */
class Jack {
    #configSet;
    #shorts;
    #options;
    #fields = [];
    #env;
    #envPrefix;
    #allowPositionals;
    #usage;
    #usageMarkdown;
    constructor(options = {}) {
        this.#options = options;
        this.#allowPositionals = options.allowPositionals !== false;
        this.#env =
            this.#options.env === undefined ? process.env : this.#options.env;
        this.#envPrefix = options.envPrefix;
        // We need to fib a little, because it's always the same object, but it
        // starts out as having an empty config set.  Then each method that adds
        // fields returns `this as Jack<C & { ...newConfigs }>`
        this.#configSet = Object.create(null);
        this.#shorts = Object.create(null);
    }
    /**
     * Set the default value (which will still be overridden by env or cli)
     * as if from a parsed config file. The optional `source` param, if
     * provided, will be included in error messages if a value is invalid or
     * unknown.
     */
    setConfigValues(values, source = '') {
        try {
            this.validate(values);
        }
        catch (er) {
            const e = er;
            if (source && e && typeof e === 'object') {
                if (e.cause && typeof e.cause === 'object') {
                    Object.assign(e.cause, { path: source });
                }
                else {
                    e.cause = { path: source };
                }
            }
            throw e;
        }
        for (const [field, value] of Object.entries(values)) {
            const my = this.#configSet[field];
            // already validated, just for TS's benefit
            /* c8 ignore start */
            if (!my) {
                throw new Error('unexpected field in config set: ' + field, {
                    cause: { found: field },
                });
            }
            /* c8 ignore stop */
            my.default = value;
        }
        return this;
    }
    /**
     * Parse a string of arguments, and return the resulting
     * `{ values, positionals }` object.
     *
     * If an {@link JackOptions#envPrefix} is set, then it will read default
     * values from the environment, and write the resulting values back
     * to the environment as well.
     *
     * Environment values always take precedence over any other value, except
     * an explicit CLI setting.
     */
    parse(args = process.argv) {
        this.loadEnvDefaults();
        const p = this.parseRaw(args);
        this.applyDefaults(p);
        this.writeEnv(p);
        return p;
    }
    loadEnvDefaults() {
        if (this.#envPrefix) {
            for (const [field, my] of Object.entries(this.#configSet)) {
                const ek = toEnvKey(this.#envPrefix, field);
                const env = this.#env[ek];
                if (env !== undefined) {
                    my.default = fromEnvVal(env, my.type, !!my.multiple, my.delim);
                }
            }
        }
    }
    applyDefaults(p) {
        for (const [field, c] of Object.entries(this.#configSet)) {
            if (c.default !== undefined && !(field in p.values)) {
                //@ts-ignore
                p.values[field] = c.default;
            }
        }
    }
    /**
     * Only parse the command line arguments passed in.
     * Does not strip off the `node script.js` bits, so it must be just the
     * arguments you wish to have parsed.
     * Does not read from or write to the environment, or set defaults.
     */
    parseRaw(args) {
        if (args === process.argv) {
            args = args.slice(process._eval !== undefined ? 1 : 2);
        }
        const options = toParseArgsOptionsConfig(this.#configSet);
        const result = (0, parse_args_js_1.parseArgs)({
            args,
            options,
            // always strict, but using our own logic
            strict: false,
            allowPositionals: this.#allowPositionals,
            tokens: true,
        });
        const p = {
            values: {},
            positionals: [],
        };
        for (const token of result.tokens) {
            if (token.kind === 'positional') {
                p.positionals.push(token.value);
                if (this.#options.stopAtPositional ||
                    this.#options.stopAtPositionalTest?.(token.value)) {
                    p.positionals.push(...args.slice(token.index + 1));
                    break;
                }
            }
            else if (token.kind === 'option') {
                let value = undefined;
                if (token.name.startsWith('no-')) {
                    const my = this.#configSet[token.name];
                    const pname = token.name.substring('no-'.length);
                    const pos = this.#configSet[pname];
                    if (pos &&
                        pos.type === 'boolean' &&
                        (!my ||
                            (my.type === 'boolean' && !!my.multiple === !!pos.multiple))) {
                        value = false;
                        token.name = pname;
                    }
                }
                const my = this.#configSet[token.name];
                if (!my) {
                    throw new Error(`Unknown option '${token.rawName}'. ` +
                        `To specify a positional argument starting with a '-', ` +
                        `place it at the end of the command after '--', as in ` +
                        `'-- ${token.rawName}'`, {
                        cause: {
                            found: token.rawName + (token.value ? `=${token.value}` : ''),
                        },
                    });
                }
                if (value === undefined) {
                    if (token.value === undefined) {
                        if (my.type !== 'boolean') {
                            throw new Error(`No value provided for ${token.rawName}, expected ${my.type}`, {
                                cause: {
                                    name: token.rawName,
                                    wanted: valueType(my),
                                },
                            });
                        }
                        value = true;
                    }
                    else {
                        if (my.type === 'boolean') {
                            throw new Error(`Flag ${token.rawName} does not take a value, received '${token.value}'`, { 